import  os

# def readrsdg(rsdg):
#     res = {}
#     f = open(rsdg,'r')
#     for line in f:
#         col = line.split()
#         name = col[0]
#         res[name] = []
#         for i in range (1,len(col)):
#             res[name].append(float(col[i]))
#     return res

def getResult(config,PRINT):
    os.system("gurobi_cl LogToConsole=0 ResultFile=max.sol problem.lp")
    res = open("max.sol",'r')
    rsdg = {}
    for line in res:
        col = line.split()
        if len(col)==2:#a result
            nodeName = col[0]
            val = float(col[1])
            nodeName = nodeName.split('-')
            if not(len(nodeName)==2):
                rsdg[col[0]] = []
                rsdg[col[0]].append(val)
                continue
            svcName = nodeName[0]
            lvl = int(nodeName[1])
            #add to rsdg
            if not(rsdg.has_key(svcName)):#not found service
                rsdg[svcName] = []
                lvlNum = config[svcName]
                for i in range(0,lvlNum):
                    rsdg[svcName].append(-1)
            rsdg[svcName][lvl-1] = val
    res.close()
    if(PRINT):printRSDG(rsdg,True)
    return rsdg

def printRSDG(rsdg,output):
    rsdgF = open("rsdg",'w')
    for i in rsdg:
        strg = ""
        lvls = rsdg[i]
        for lvl in lvls:
            strg+=str(lvl) + " "
        rsdgF.write(i + ":"+ strg + "\n")
        if output: print (str(i) + ":"+ strg + "\n")

def genProblem(res,constraints,kf):
    prob = open("problem.lp",'w')
    #write obj
    prob.write("Minimize\nerr\n\n")
    #write order constraint
    prob.write("Subject To\n")
    #for s in res:
    #    lvls = res[s]
    #    for i in range(1,lvls):
    #        prob.write(s + "-" + str(i) + " - " + s + "-" + str(i+1) + " > 1\n")
    #prob.write("\n")
    #write observation constraint
    for c in constraints:
        prob.write(c)

    #write bounds
    prob.write("Bounds\n")
    for s in res:
        lvls = res[s]
        if(lvls==0):continue
        prob.write(s+"-"+str(lvls) + " = 0\n")

    #write known facts
    prob.write(kf)

    #write end
    prob.write("End")
    prob.close()

# return an array of RAPIDConfig's
def generateConstraintsFromTraining(fileName):
    f = open(fileName,'r')
    constraints = []
    dualConstraints = []
    for line in f:
        constraint = []
        col = line.split(',')
        length = len(col)
        name = ""
        lvl = -1
        for i in range(0,length):
            if i==length-1:
                constraint = constraint[:-2]#delete the last ","
                cost = col[i]
                dualConstr = constraint #dual constraint restrict the error bound
                constraint += ">= " + cost + "\n"
                dualConstr += "- " + cost + " err <= "+ cost + "\n"
                #add to constraints array
                constraints.append(constraint)
                dualConstraints.append(dualConstr)
                continue
            cur = col[i]
            if not(cur.isdigit()):#if it's service name
                name = cur
            else:
                lvl = int(cur)
                if not(lvl==0):
                    constraint += name + "_" + str(lvl) + " + "
                else:
                    constraint += name + " + "

    return constraints, dualConstraints

def parseKF(KF):
    kf = open(KF,'r')
    kfc = ""
    for line in kf:
        col = line.split()
        kfc += col[0] + " = " + col[1] + '\n'
    return kfc;
